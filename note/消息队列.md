# 消息队列

## 目录

* [消息重复](#消息重复)
* [消息丢失](#消息丢失)
* [消息积压](#消息积压)
* [消息队列是如何实现分布式事务](#消息队列是如何实现分布式事务)
---

## 消息重复

幂等性设计

- 使用唯一id；
- 对于处理过的消息进行保存，收到消息后，根据消息的唯一id更新查询，判断消息是否处理过；

---

## 消息丢失

看到过一些方案，基本的思路都是基于消息确认机制

方案零：

* 利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在发送端，给每个发出的消息附加一个连续递增的序号，然后在接受端来检查这个序号的连续性。

方案一：
    
* 发送方发送消息之后，挂一个timer，如果在timer到期之后，还没有收到rsp，那就认为出现的了超时。超时有两种可能，第一种是消息在路上丢掉了，第二种是收消息的一方挂了，或者是消息堆积了，没有来得及处理。

方案二：

*   发送方在发送的时候，在db中插入一条记录；消息的接收方在收到消息之后，从db查询到这条记录，然后更新db的状态位。

    这样做后，即使出现了消息丢失，也可以通过定时任务扫描出一段时间内未完成的消息，进行重新投递.


-----

## 消息积压

发送方太快，收消息方太慢。速度不匹配。

1. 发送方降低速度
2. 收消息方 多开实例，优化热点等

----
## 消息队列是如何实现分布式事务

to-do