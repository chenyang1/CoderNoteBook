# 函数的调用过程

## 目录

* [函数的调用过程统](#函数的调用过程)
* [函数栈切换](#函数栈切换)
* [协程的基本原理](#协程的基本原理)
* [热更新的基本原理](#热更新的基本原理)
---

## 函数的调用过程

* 函数的调用栈示意图:
![tu](../pic/函数调用1.png)

* 函数调用对应的汇编代码:
![tu](../pic/函数调用2.png)

    通过gdb disas/rs + 函数名称 可以查看对应的汇编代码。查看汇编发现:

    1. 在main调用add函数的时候，这里的参数是通过寄存器在传递的
    2. 每进入一个新的函数之后，都是 push %rbp，mov %rsp,%rbp。开辟新的rbp 和 rsp
    3. 返回的返回值存放在eax中
    4. 函数如何return （todo）

* c调用汇编的代码

    在c语言中，使用asm可以调用汇编:
    ```
    void function();

    void test()
    {
        int val = 10;
        printf("val %d\n", val);
        
        // set val = 11
        asm("movl $0xb, -0x4(%rbp)");
        printf("val %d\n", val);
        
        long addr = function;
        asm("movl $0x401156, 0x18(%rbp)");
    }
    ```

    完成代码：

    [example_code](../example_code/function/test_asm.c)

## 函数栈切换

搞明白函数的调用过程，可以进一步去思考如何去进行函数切换。

1. 思路1：堆栈溢出攻击

    覆盖返回地址，实现函数跳转。
    ```
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <unistd.h>

    void fun() 
    {
        while(1) 
        {
            printf("Hello, I'm fun!\n");
            sleep(1);
        }
    }

    int foo2()
    {
        long a[5] = { 0 };
    
        // 溢出攻击
        a[9] = fun;                 // 覆盖返回地址  // 为什么是a[9] 尝试不同的移动偏移去覆盖rbp的上一条地址 (不同的机器可能不太一样)
    }

    int main() 
    {
        printf("main \n");
        foo2();
        return 0;
    }
    ```


2. 思路2：覆盖函数的地址的汇编代码，实现函数跳转

    ```
    void fun() 
    {
        while(1) 
        {
            printf("Hello, I'm fun!\n");
            sleep(1);
        }
    }

    int foo()
    {
        int a[5] = { 0 };
    
        // 溢出攻击
        asm("mov $0x401136,%eax");    // 0x401136 是fun的入口地址
        asm("mov %rax,0x18(%rbp)");
    }
    ```

    fun的地址可以通过查看汇编代码找到：
    ![](../pic/函数调用3.png)

    执行结果：
    ![](../pic/函数调用4.png)

3. 思路3：覆盖函数的地址首部，插入跳转到其他函数的汇编代码，实现函数跳转

    如果想要从函数a调到函数b，可以把函数b的栈copy覆盖过去。

    ```
    // 希望跳转到的函数
    (gdb) disas/rs MyFunctionNew
    Dump of assembler code for function MyFunctionNew:
    0x0000000000401334 <+0>:     55      push   %rbp
    0x0000000000401335 <+1>:     48 89 e5        mov    %rsp,%rbp
    0x0000000000401338 <+4>:     89 7d ec        mov    %edi,-0x14(%rbp)
    0x000000000040133b <+7>:     89 75 e8        mov    %esi,-0x18(%rbp)
    0x000000000040133e <+10>:    c7 45 fc 0a 00 00 00    movl   $0xa,-0x4(%rbp)
    0x0000000000401345 <+17>:    8b 45 fc        mov    -0x4(%rbp),%eax
    0x0000000000401348 <+20>:    5d      pop    %rbp
    0x0000000000401349 <+21>:    c3      retq   
    End of assembler dump.
    ```


    ```
    // 希望跳转到的函数的对应的汇编代码
    char new_func[] = 
    {
    0x55,
    0x48, 0x89, 0xe5, 
    0x89, 0x7d, 0xec, 
    0x89, 0x75, 0xe8, 

    0xc7, 0x45, 0xfc, 0x0a, 0x00, 0x00, 0x00,

    0xc7, 0x45, 0xf8, 0x01, 0x00, 0x00, 0x00, 

    0x8b, 0x45, 0xfc, 
    0x5d, 
    0xc3  
    };
    ```

    ```
    // 用新的代码去覆盖旧的函数的代码
    int len = sizeof(new_func);
    memcpy((void*)MyFunction, (void*)new_func, len);
    ```

    完成代码：

    [example_code](../example_code/function/test.c)

4. set/jump的方案

    ```
    jmp_buf env;

    int my_func(int a, int b) 
    {
        if (b == 0) {
            printf("do not allow division by 0\n");
            longjmp(env, 1);
        }
        return a / b;
    }

    int main(int argc, char const *argv[]) 
    {
        int res = setjmp(env);
        if (res == 0) {
            printf("return from setjmp\n");
            my_func(10, 0);
        } else {
            printf("return from longjmp: %d\n", res);
        }
        return 0;
    }
    ```

    完成代码：

    [example_code](../example_code/function/test_jmp.c)

## 协程的基本原理

核心 ：

ucontext协程库 上下文切换的思路

libco 上下文切换的思路 


1. 共享栈 和 非共享栈 协程的区别 

2. libco hook 系统函数的思路


## 热更新的基本原理

    todo
