# 函数的调用过程

## 目录

* [函数的调用过程统](#函数的调用过程)
* [函数栈切换](#函数栈切换)
* [协程的基本原理](#协程的基本原理)
* [热更新的基本原理](#热更新的基本原理)
---

## 函数的调用过程

* 函数的调用栈示意图:
![tu](../pic/函数调用1.png)

* 函数调用对应的汇编代码:
![tu](../pic/函数调用2.png)

    通过gdb disas/rs + 函数名称 可以查看对应的汇编代码。查看汇编发现:

    1. 在main调用add函数的时候，这里的参数是通过寄存器在传递的
    2. 每进入一个新的函数之后，都是 push %rbp，mov %rsp,%rbp。开辟新的rbp 和 rsp
    3. 返回的返回值存放在eax中
    4. 函数如何return （todo）

* c调用汇编的代码

    todo

## 函数栈切换

搞明白函数的调用过程，可以进一步去思考如何去进行函数切换。

1. 思路1：堆栈溢出攻击

    覆盖返回地址，实现函数跳转

2. 思路2：覆盖函数的地址的汇编代码，实现函数跳转

3. 思路3：覆盖函数的地址首部，插入跳转到其他函数的汇编代码，实现函数跳转

4. set/jump的方案

## 协程的基本原理

核心 ：

ucontext协程库 上下文切换的思路

libco 上下文切换的思路 


1. 共享栈 和 非共享栈 协程的区别 

2. libco hook 系统函数的思路

3. 

## 热更新的基本原理
todo
