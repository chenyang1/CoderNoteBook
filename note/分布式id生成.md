# 分布式id生成


## 目录
* [集中式的唯一id生成](#集中式的唯一id生成)
* [分布式的唯一id生成](#分布式的唯一id生成)

---

在很多场景中，都有需要生成唯一id的需求。这个问题抽象出来，**就是在分布式的环境下，如何生成不重复的id？**。

常见的几种方案，大概是两个思路去做。分别是集中式的id分配（通过一个唯一的中心节点生成id，其他进程向中心节点申请id）和分布式的id分配（进程本地生成 无需网络调用）思路。

---

## 集中式的唯一id生成

提供一个中心节点，其他的业务进程需要使用id的时候，想中心节点去申请。中心节点是唯一的，可以保证分配出来的id是不重复的。

具体实现的细节：

1. 不同的业务可以注册不同的号码段，中心节点根据提前注册业务的号码段给他们分配出不同的id。

    ```
    +------+-------------------+
    | type | type_seq_used_max |
    +------+-------------------+

    db中保存两个字段，一个是类型id，一个是当前类型已使用的最大id。这样重启之后，可以保存上次分配最大值。
    ```

    具体的字段格式可以是：
    ```
    唯一id （64位长度）
    type id （8位），其他固定信息（比如区服信息）（6位），seq（50位）
    ```

    seq字段在db中记录了已经使用的最大值，每次分配的时候自增（保证不重复）。
    
    服务重启的时候，已经分配的最大值存盘。保证下次重启的时候，继续在最大值只上分配（保存重启不会重复）。

    seq的长度是50位，2的50次方，是一个非常非常大的数，足够用非常久了。

2. 申请的时候，可以采用一个双buff的思想，比如业务a要申请，可以一次申请1000个可用，1000个备用。业务a拿到之后，在自己的进程上慢慢使用。当1000个用完的时候，切换到备用上。同时，再次向中心节点申请。

    这样的优点可以保证业务使用的时候，可以直接从当前进程的缓存里拿id，不需要异步等待。

    这种方案还有一个额外的好处，发号的策略不依赖于时间。对于调服务器时间这种操作，可以完全不受影响。

* 其他集中式的唯一id生成的方案

    这里还有一些其他的利用mysql主键自增，redis inc 命令维护，zk等组件实现唯一id生成的思路或方案，

    本质上也是利用**一个唯一的中心节点去发号**，不同的方案各有利弊，也是针对不同的业务场景提供的解决办法。

---

## 分布式的唯一id生成

* uuid的思路

    UUID（Universally Unique Identifier，即通用唯一标识码），uuid的格式是32位的字符串，利用mac地址和时间组成的唯一id。

    优点：

    1.  uuid 的思路利用的mac地址和时间来作为不重复的依据，它的优点是性能很好

    2. id可以本地生成，没有网络消耗。

    缺点：

    1. uuid太长，是字符串的格式，存储成本高

    2. 暴露机器的mac地址


* 雪花like算法的思路

    这种方案的思路是，每个进程都在自己的本地去分配id，不需要异步和通过网络去申请。不过呢，为了避免进程a和进程b生成了相同的id，要划分不同的号码区间。

    比如，类似于雪花算法的id生成思路，将一个64位的bit段，分为不同的区间。（时间 + 机器id + 序号）类似于这样。保证在某一个时间下，可以生成的id都是唯一的。

    仔细想了一下，雪花算法这几个字段的排列方式，还是很有道理的。

    ```
    unsigned long long make_id()
    {
        u32 time = get_time();
        u32 machine_id = get_machine_id();

        static u32 seq = 0;
        u64 id = time < xxx | machine_id < xxxx | seq++;
    return id;
    }
    ```

* 为什么时间作为最高位？
   
   因为用时间作为做高位，保证的id是单调增长的。如果id是用在做数据库主键的，可以保证主键的写入是一直追加到索引的后面的。

* 为什么seq最为最低位？

    seq要放在最后，而且推荐写为static，这样会不停的加，id分布是均匀的。如果id用来hash = (id % 10)，那可以保证hash后的结果是分布均匀的。
    当时，如果用时间作为最后一位 或机器id作为最后一位，那么就不一定了。


* 这里有可能出现一个**时钟回拨**的问题：

    时钟回拨指的是：
    时间回拨问题是指系统在运行过程中，可能由于网络时间校准或者人工设置，导致系统时间主动或被动地跳回到过去的某个时间。

    美团的一个分布式id的文章提供了一个解决办法，增加了一个时钟id的字段。当现在的时间小于等于上次申请的时间的时候，时钟id++。不过这个只能解决系统没有重启的情况。（如果遇到系统重启 + 时间回拨 那问题就这个方式就没有办法了）

    如果这里问题要解决的话，好像也是可以的。

    刚才提及的雪花like算法，都是从进程本地获得的；如果进程重启后，出现时间回拨（或者测试的时候，qa修改进程的时间，然后又改回去）。可以单独搞一个分配id的进程或服务器，通过网络去获得。这样只需要保证这个单独的服务时间重启后不会拨就好。

    这样还有一个好处，可以解决 雪花算法中机器id的字段。但是呢，问题是中间加入了通过网络去申请的异步过程。要看业务特点什么去权衡了。

----

## 参考：

https://tech.meituan.com/2017/04/21/mt-leaf.html

https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/