# 分布式id生成

在很多场景中，都有需要生成唯一id的需求。这个问题抽象出来，就是在分布式的环境下，如果不重复的id。

常见的几种方案

方案一：

集中式的唯一id生成，类似于预约一个号码段，不同的业务向一个中心节点去申请号段。


方案二：
类似于雪花算法的id生成思路，将一个64位的bit段，分为不同的区间。（时间 + 机器id + 序号）类似于这样。保证在某一个时间下，可以生成的id都是唯一的。

仔细想了一下，雪花算法这几个字段的排列方式，还是很有道理的。

```
unsigned long long make_id()
{
    u32 time = get_time();
    u32 machine_id = get_machine_id();
    
    static u32 seq = 0;
    u64 id = time < xxx | machine_id < xxxx | seq++;
    return id;
}
```

* 为什么时间作为最高位？
   
   因为用时间作为做高位，保证的id是单调增长的。如果id是用在做数据库主键的，可以保证主键的写入是一直追加到索引的后面的。

* 为什么seq最为最低为？

    seq要放在最后，而且推荐写为static，这样会不停的加，id分布是均匀的。如果id用来hash = (id % 10)，那可以保证hash后的结果是分布均匀的。
    当时，如果用时间作为最后一位 或机器id作为最后一位，那么就不一定了。


这里有可能出现一个时钟回拨的问题：

时钟回拨指的是：
时间回拨问题是指系统在运行过程中，可能由于网络时间校准或者人工设置，导致系统时间主动或被动地跳回到过去的某个时间。

美团的一个分布式id的文章提供了一个解决办法，增加了一个时钟id的字段。当现在的时间小于等于上次申请的时间的时候，时钟id++。不过这个只能解决系统没有重启的情况。（如果遇到系统重启 + 时间回拨 那问题就这个方式就没有办法了）

如果这里问题要解决的话，好像也是可以的。

刚才提及的雪花like算法，都是从进程本地获得的；如果进程重启后，出现时间回拨（或者测试的时候，qa修改进程的时间，然后又改回去）。可以单独搞一个分配id的进程或服务器，通过网络去获得。这样只需要保证这个单独的服务时间重启后不会拨就好。

这样还有一个好处，可以解决 雪花算法中机器id的字段。但是呢，问题是中间加入了通过网络去申请的异步过程。要看业务特点什么去权衡了。

链接：

https://tech.meituan.com/2017/04/21/mt-leaf.html

https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/