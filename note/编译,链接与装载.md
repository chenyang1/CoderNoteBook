# 编译，链接与装载

## 目录

* [编译](#编译)
    * [编译](#编译)
    * [构建工具](#构建工具)

* [静态库](#静态库)
    * [制作一个静态库](#制作一个静态库)
    * [链接静态库](#链接静态库)
    * [链接库的时候的路径依赖问题](#链接库的时候的路径依赖问题)
* [动态库](#动态库)
    * [动态库的优点](#动态库的优点)
    * [制作一个动态库](#制作一个动态库)
    * [链接动态库](#链接动态库)
    

---
## 编译

### 编译一个文件的流程

把一个.cpp文件编译成为可执行的文件,按照教科书上面的流程是：

    预处理 --> 汇编代码 --> 链接 --> 可执行的机器码

如果是用g++写的话：

    g++ main.cpp  # 这样一步就生成了a.out 文件

如果需要多个文件编译的话：

    g++ mian.cpp func.cpp 

    # or
    g++ -c func.cpp 
    g++ main.cpp func.o

    # or 
    g++ 的 -I -L 选项，可以include相应的头文件和库文件（对于大型项目）


初学c++的时候，被这些困扰了很久，为了搞明白，写了很多笔记类的blog。

* Linux下 C++代码编译和链接文件的具体过程和分析：
https://www.jianshu.com/p/c682a5a23288

* LINUX下默认搜索头文件及库文件的路径：
https://www.jianshu.com/p/3eb25114576e

* 在linux下使用gcc/g++编译多个.h .c 文件：
https://www.jianshu.com/p/e5c6a255076b

### Make构建工具

    make 
    # https://www.jianshu.com/p/0107cae15e5a

    make 自动推导
    # https://www.jianshu.com/p/27070bbcba4d

## 静态库

文件目录结构
```
├── lib
│   ├── print.cc
│   └── print.h
└── main.cc
```

main.cc文件里面调用了print.cc里面实现的print_func 函数。如果使用g++编译的话，
```
g++ main.cc ./lib/print.cc
```

### 制作一个静态库

静态库可以认为是一堆.o 文件的集合。可以使用ar命令，将他们打包成一个静态库。
```
# ar -crv 静态库的名字  .o文件的名字
# 注意静态库的名字必须是lib开头，比如libmuduo

ar -crv libprint.a print.o        # 将.o 文件打包生成一个libprint的静态库
                                  # 于是就会生成一个libprint的静态库
```
### 链接静态库
目录结构，如下：(注意，现在已经没有源码了，只有静态库和头文件)
```
.
├── lib
│   ├── libprint.a
│   └── print.h
└── main.cc
```

```
# 编译一下
g++ main.cc -L ./lib/ -lprint
```

-L 指定了链接静态库的路径

-l 指定了链接静态库的名字，但是这个命令的规则是去掉了前面的lib


### 链接库的时候的路径依赖问题

如果需要链接两个库，A和B。链接的时候，可以这样写
```
g++ main.cc -L ./lib/ -lA -lB
```

但是，如果A和B之间存在依赖关系，比如A依赖于B，那么就要把B写在前面。

如果相互依赖就应该为A B A或者B A B的顺序。



## 动态库


### 动态库的优点

* 节约空间，所有的可执行文件，可以共享库文件。

* 更新的时候，比较方便。（不需要把每个可执行文件都重新编译）


### 制作一个动态库

* 命名规则

    动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为“.so”。

* 创建动态库

文件的目录结构
```
.
├── lib
│   ├── print.cc
│   └── print.h
└── main.cc
```

首先，先把print.cc编译生成.o 文件,但是这里需要加入一个 -fPIC
```
g++ -fPIC -c print.cc
```

制作动态库
```
g++ -shared -o libdynamicprint.so print.o
```

这样就生成了 .so 的动态库。

### 链接动态库
对于生成的动态库，目录结构如下：
```
├── a.out
├── lib
│   ├── libdynamicprint.so
│   ├── print.cc
│   ├── print.h
│   └── print.o
└── main.cc
```

编译：
```
g++ main.cc -L ./lib/ -ldynamicprint
```

**但是，这样直接运行，会出问题！！！！！**
```
./a.out
./a.out: error while loading shared libraries: libdynamicprint.so: cannot open shared object file: No such file or directory
```

这个原因是动态库有一个默认的链接路径，如果不再那个路径中，系统就找不到这个so的库。所以，必须指明它的路径。

解决的办法：

* 如果这个库，在/usr/lib下，ld就会找到这个这个文件。所以，解决的办法就是将将这个动态库so文件拷贝到/usr/lib的里面。
    ```
    sudo cp libdynamicprint.so /usr/lib/
    ```

* 如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：

    1. 编辑/etc/ld.so.conf文件，加入库文件所在目录的路径
    2. 运行ldconfig ，该命令会重建/etc/ld.so.cache文件

* 使用LD_LIBRARY_PATH在里面添加路径
    ```
    #LD_LIBRARY_PATH=/usr/local/libgd/lib
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/library
    export LD_LIBRARY_PATH
    ```

* 使用rpath将动态库的路径指定到编译的生成的可执行文件中
    ```
    dependencies_include_path=/data/home/your_path
    dependencies_lib_path=/data/home/your_lib

    // -rpath 执行lua库的位置
    g++ -g -I${dependencies_include_path}/lua-5.1.4/src -L ${dependencies_lib_path} -llua -Wl,-rpath=${dependencies_lib_path} test.cpp -o test
    ```

    ```
    // 编译的时候 如果不通过-rpath 指定的话 ldd查看的话，是找不到liblua的
    ldd test5                                                                                             
    linux-vdso.so.1 =>  (0x00007ffff7ffa000)
    /$LIB/libonion.so => /lib64/libonion.so (0x00007ffff7bd5000)
    liblua.so => not found
    libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007ffff78cd000)
    libm.so.6 => /lib64/libm.so.6 (0x00007ffff75cb000)
    libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007ffff73b5000)
    libc.so.6 => /lib64/libc.so.6 (0x00007ffff6fe7000)
    libdl.so.2 => /lib64/libdl.so.2 (0x00007ffff6de3000)
    /lib64/ld-linux-x86-64.so.2 (0x00007ffff7ddb000)

    // 编译的时候，加上rpath
    ldd test5                                                                                             
    linux-vdso.so.1 =>  (0x00007ffff7ffa000)
    /$LIB/libonion.so => /lib64/libonion.so (0x00007ffff7bd5000)
    liblua.so => /lib/liblua.so (0x00007ffff7ebf000)
    libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007ffff78cd000)
    libm.so.6 => /lib64/libm.so.6 (0x00007ffff75cb000)
    libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007ffff73b5000)
    libc.so.6 => /lib64/libc.so.6 (0x00007ffff6fe7000)
    libdl.so.2 => /lib64/libdl.so.2 (0x00007ffff6de3000)
    /lib64/ld-linux-x86-64.so.2 (0x00007ffff7ddb000)
    ```

* 补充

    动态库有一个好处就是更新的时候，不需要重新编译a.out文件。比如，lib文件里面的print.cc函数里面重新修改了一下,只要将lib重新编译好，打包好就可以了。a.out运行的时候，再执行这个函数，发现它已经被修改了。

    这样就又引出一个新的概念，就是**ABI**。二进制兼容。就是一个合格的库设计的时候，要注意自己的二进制兼容。


    **ABI的定义是**: 不必重新编译a.out文件，并且程序的功能不必被破坏。