# 分布式锁

## 目录

* [使用zk作为分布式锁](#使用zk作为分布式锁)
* [使用redis作为分布式锁](#使用redis作为分布式锁)

---

## 使用zk作为分布式锁

1. 在锁的目录下面，创建临时有序节点

2. 每个节点需要申请锁的时候，在这个目录下面创建临时节点

3. 在锁的目录下面，锁的序号最小的一个节点认为拿到了锁

4. 后面的节点 依次watch前面的节点，当前面的节点变更的时候，后面的节点被唤醒，进行step3的判断

举个例子：

1) 比如某进程获得到的节点序号为 /zk_lock/003，然后所有的节点列表为[/zk_lock/001，/zk_lock/002，/zk_lock/003]，则对 /zk_lock/002 这个节点添加一个事件监听器。

2) 如果锁释放了，会唤醒下一个序号的节点，判断是否自己的节点序号是最小。

3) 比如 /zk_lock/001 释放了，/lock/002 监听到时间，此时节点集合为[/zk_lock/002，/zk_lock/003]，则 /lock/002 为最小序号节点，获取到锁。

优点：
1. 临时有序的zk节点，可以保证当进程挂掉的时候，锁还是可以被释放的。

2. 每个节点watch前面的节点，相当于一个订阅回调的机制，这样业务层使用起来更舒服。


## 使用redis作为分布式锁

在redis上面设置一个key作为锁

1. 一个进程先去get这个key，如果不存在，表示锁不存在。那么就 set 这个值，表示持有这个锁
    ```
    if redis.call("get", key) == NULL then
        -- 持有锁
        redis.call("set", key, expire_time)
    else 
        -- 已经被其他的进程抢占了
        return;
    end
    ## 这里有一个判断key是否存在，然后set value连个步骤
    ## 为了保证操作的原子性，可以通过lua脚本来操作
    ```

2. 如果持有锁的进程需要释放锁的时候，去删除这key。

这个方案很简单，但是缺点是：
1. 持有锁的进程如果在超时之后，需要继续持有锁，那么就比较不方便了

改良版：

Redisson 是一个基于redis的框架，提供了一个watch-dog的服务。原理非常简单，就是把超时时间设置的比较短，然后不断的去自动延长这个时间。如果当进程挂的时间，失去心跳，这个锁会超时释放。或者是知道进程使用完锁，去主动释放。


